---
title: "Is the mushroom good to eat?"
author: "Simon Lee"
date: "UCSB Fall 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Mushroom Classification


## Introduction
The goal of this project is to build different models that predict whether or not a certain certain mushroom is edible or
poisonous. 
```{r message = FALSE}
library(tidymodels)
library(tidyverse)
library(ggplot2)
library(corrr)
library(corrplot)
library(klaR)
library(glmnet)
library(MASS)
library(discrim)
library(poissonreg)
library(janitor)
library(rpart.plot)
library(vip)
library(randomForest)
library(xgboost)
library(recipes)
library(dplyr)
library(ranger)
tidymodels_prefer()
```


```{r}
# reading in the data
rawData <- read.csv("mushrooms.csv")
dim(rawData)
```
There is 8124 observations and 23 variables for each of the observations.

Lets also check how many levels for each categorical variable we have. So we would have a better idea when we turn them into
factors the unique values given to each variable

```{r}
# map_df function from dplyr package in order to make each variable a factor. 
mushroom <- rawData %>% map_df(function(.x) as.factor(.x))

# The function is used to calculate the amount of levels(or categories) each variable has
levelCount <- function(x){
  x <- length(levels(x))
}

x <- mushroom %>%  map_dbl(function(.x) levelCount(.x))  %>%  as_tibble()  %>%  
       rownames_to_column()  %>%  arrange(desc(value))
colnames(x) <- c("Variable #", "Number of levels")
print(x)
```
As we can see with all the different variables, the amount of levels within each variable ranges
from 1-12. Noticing that variable 17, (veil_type) has only one level, which means that all of the
observations have the same value for that variable. With only one factor, it does not help us in determining
the edibility of a mushroom and will be removed from the data.

```{r}
mushroom <- mushroom %>% select(- veil.type)
```

At this point, it might also be good to check whether or not our data has missing values
```{r}
colSums(is.na(mushroom)) / nrow(mushroom)
```

Luckily for us. This data set found on kaggle does not have any missing values.

Let's take a look at the distribution of edible mushroom to poisonous in our dataset
```{r}
mushroom %>% ggplot(aes(x= class)) + geom_bar()
```

The ratio of poisnous to edible mushrooms in the dataset is around the same. With there being slightly more
edible mushrooms than poisonous ones.

## Data Cleaning

Before visualizing some of the data with ggplot, let's make the data prettier looking. And by that I mean
changing the variable names and level names to make them easier to understand.

```{r}
colnames(mushroom) <- c("edibility", "cap_shape", "cap_surface", "cap_color", "bruises", "odor", "gill_attachment",
                        "gill_spacing", "gill_size", "gill_color", "stalk_shape", "stalk_root", "stalk_surface_above_ring",
                        "stalk_surface_below_ring", "stalk_color_above_ring", "stalk_color_below_ring", "veil_color",
                        "ring_number", "ring_type", "spore_print_color", "population", "habitat")
levels(mushroom$edibility) <- c("edible", "poisonous")
levels(mushroom$cap_shape) <- c("bell", "conical", "flat", "knobbed", "sunken", "convex")
levels(mushroom$cap_surface) <- c("fibrous", "grooves", "scaly", "smooth")
levels(mushroom$cap_color) <- c("buff", "cinnamon", "red", "gray", "brown", "pink", "green", "purple", "white", "yellow")
levels(mushroom$bruises) <- c("no", "yes")
levels(mushroom$odor) <- c("almond", "creosote", "foul", "anise", "musty", "none", "pungent", "spicy", "fishy")
levels(mushroom$gill_attachment) <- c("attched", "free")
levels(mushroom$gill_spacing) <- c("close", "crowded")
levels(mushroom$gill_size) <- c("broad", "narrow")
levels(mushroom$gill_color) <- c("buff", "red", "gray", "chocolate", "black", "brown", "orange", "pink", "green",
                                 "purple", "white", "yellow")
levels(mushroom$stalk_shape) <- c("enlarging", "tapering")
levels(mushroom$stalk_root) <- c("missing", "bulbous", "club", "equal", "rooted")
levels(mushroom$stalk_surface_above_ring) <- c("fibrous", "silky", "smooth", "scaly")
levels(mushroom$stalk_surface_below_ring) <- c("fibrous", "silky", "smooth", "scaly")
levels(mushroom$stalk_color_above_ring) <- c("buff", "cinnamon", "red", "gray", "brown", "orange", "pink",
                                             "white", "yellow")
levels(mushroom$stalk_color_below_ring) <- c("buff", "cinnamon", "red", "gray", "brown", "orange", "pink",
                                             "white", "yellow")
levels(mushroom$veil_color) <- c("brown", "orange", "white", "yellow")
levels(mushroom$ring_number) <- c("none", "one", "two")
levels(mushroom$ring_type) <- c("evanescent", "flaring", "large", "none", "pendant")
levels(mushroom$spore_print_color) <- c("buff", "chocolate", "black", "brown", "orange", "green", "purple",
                                        "white", "yellow")
levels(mushroom$population) <- c("abundant", "clustered", "numerous", "scattered", "several", "solitary")
levels(mushroom$habitat) <- c("wood", "grasses", "leaves", "meadows", "paths", "urban", "waste")
```


## EDA

Now lets use ggplot to see a general idea of which variables might be useful in predicting the edibility of a mushroom

The variables that I'm interested in visualizing is all of the color variables in the data set. This is due to the general assumption that as a survival tactic, you shouldn't eat bright colored things in nature. The term used is aposematism where it is the trait of an organism which advertises to its predators to not attack or eat it. So I'm going to make bar charts of all the
color variables and see the ratio of edible vs poisonous mushroom within each color. That way I can kind of get a general idea
of how important each variable is to predicting the edibility of the mushroom.

```{r echo = FALSE}
ggplot(data = mushroom, aes(x = cap_color, fill = edibility)) + geom_bar()
ggplot(data = mushroom, aes(x = gill_color, fill = edibility)) + geom_bar()
ggplot(data = mushroom, aes(x = stalk_color_above_ring, fill = edibility)) + geom_bar()
ggplot(data = mushroom, aes(x = stalk_color_below_ring, fill = edibility)) + geom_bar()
ggplot(data = mushroom, aes(x = veil_color, fill = edibility)) + geom_bar()
ggplot(data = mushroom, aes(x = spore_print_color, fill = edibility)) + geom_bar()
```

Looking at the four different bar charts. It seems that the color of the cap of the mushroom doesn't contribute too much to
whether or not the mushroom is edible or not. Within each cap_color, there are edible and poisonous except for green and purple which suggests that its edible. However the count size is too small to conclude anything. More interestingly in the second bar graph, if the mushroom has a buff gill_color, then it is poisonous. stalk_color_above_ring and stalk_color_below_ring have the
same distribution which makes sense as the color of the stalk below and above the ring should be the same. From this bar chart,
notable colors include gray which indicates the mushroom is edible and brown which indicates that the mushroom is poisonous. The
veil_color does not appear to be helpful for our purpose of determining the edibility of the mushroom. spore_print_color seems
to be the most useful out of the color attributes in determining the edibility of a mushroom. (buff, black, brown, orange, purple
yellow) colored spore_print most likely indicates that the mushroom is edible. (chocolate, green, white) colored spore_print indicates that the mushroom is most likely to be poisonous.


### Let's also take a look at some correlation between our variables

In order to do that, I will be changing all the categorical variables to numeric except the response variable, edibility.
```{r}
mushroom_num <- mushroom %>% map_df(function(.x) as.numeric(.x))
mushroom_num <- mushroom_num %>% select(-edibility)
mushroom_cor <- cor(mushroom_num)
mushroom_corplot <- corrplot(mushroom_cor, order = "AOE", type = "lower", tl.cex = 0.7)
```

From the correlation plot, we can see that not many of our variables correlate with each other. This makes sense as its a data set of mostly categorical variables. Which even after being turned numeric values wouldn't make any sense in correlation. Which means that most of them don't interact with one another which will make the recipe step much easier. Though a thing to keep an
eye out for would be the variables ring_number, bruises, gill_size, and stalk_shape. ring_number is originally a numerical variable and gill_size/stalk_shape have only 2 levels so after changing them to numbers they could still be used in correlation.

Let's take a look at the interaction between these 3 variables
```{r}
mushroom_cor1 <- mushroom_num %>% 
  select(c(ring_number, stalk_shape, gill_size)) %>% 
  correlate() %>% 
  stretch() %>% 
  ggplot(aes(x,y,fill = r)) + geom_tile() + geom_text(aes(label = as.character(fashion(r))))
mushroom_cor1
```

There is some very weak positive/negative correlation between these variables. Which could lead me to assume
that there is no interaction between these variables.

## Model Making

It's time to split our data into the training/testing set. Create a recipe. And build different models to predict
whether or not a mushroom is edible based on its attributes

### Splitting the Data
```{r}
# seed is used to make sure that we can reproduce our data
set.seed(115)

mush_df <- rawData  %>% 
  mutate_if(is.character, as.factor) %>% 
  select(-c(bruises, gill.attachment, veil.type))


# Splitting our data into 80% training and 20% testing as well as using our response variable edibility as the strata
mush_split <- mush_df %>% initial_split(prop = 0.8, strata = class)
mush_train <- training(mush_split)
mush_test <- testing(mush_split)
```

Let's quickly check the dimensions of our training/testing set
```{r}
dim(mush_train)
dim(mush_test)
```

There are 6498 observation in the training data set and 1626 observations in the testing data set

## Recipe Building

Fortunately, using tidymodels means that we only have to create one recipe for use in all of our models. 
```{r}
mush_recipe <- recipe(class~., data = mush_train) %>% 
  step_novel(all_nominal_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_zv(all_predictors()) %>% 
  step_normalize(all_predictors())
mush_recipe

mush_folds <- vfold_cv(mush_train, v = 10)
mushrooms_prep <- prep(mush_recipe)
```


```{r}
log_reg <- logistic_reg() %>% 
  set_engine("glm") %>% 
  set_mode("classification")

log_wkflow <- workflow() %>% 
  add_recipe(mush_recipe) %>% 
  add_model(log_reg)

lda_mod <- discrim_linear() %>% 
  set_engine("MASS") %>% 
  set_mode("classification")

lda_wkflow <- workflow() %>% 
  add_recipe(mush_recipe) %>% 
  add_model(lda_mod)
```


```{r error=FALSE, warning=FALSE}
log_fit <- fit_resamples(log_wkflow, mush_folds)
lda_fit <- fit_resamples(resamples = mush_folds, lda_wkflow)
```


```{r}
collect_metrics(log_fit)
collect_metrics(lda_fit)
```

```{r}
lda_fit_train <- fit(log_wkflow, mush_train)
lda_test <- fit(lda_wkflow, mush_test)

predict(lda_test, new_data = mush_test, type = "class") %>% 
  bind_cols(mush_test %>% select(class)) %>% 
  accuracy(truth = class, estimate = .pred_class)
```


```{r include= FALSE}
mush_spec <- decision_tree(cost_complexity = tune()) %>% 
  set_mode("classification") %>% 
  set_engine("rpart")

mush_tree_wf <- workflow() %>% 
  add_recipe(mush_recipe) %>% 
  add_model(mush_spec)

param_grid_tree <- grid_regular(cost_complexity(range = c(-3,-1)), levels = 10)

tune_res_tree <- tune_grid(mush_tree_wf, resamples = mush_folds, grid = param_grid_tree, metrics = metric_set(roc_auc))
```

```{r}
autoplot(tune_res_tree)
```

```{r}
collect_metrics(tune_res_tree) %>% arrange(desc(mean))
best_parameter_tree <- select_best(tune_res_tree, metric = "roc_auc")
best_parameter_tree
```

```{r}
mush_tree_final <- finalize_workflow(mush_tree_wf, best_parameter_tree)
mush_tree_fit <- fit(mush_tree_final, data = mush_train)
mush_tree_fit %>%  extract_fit_engine %>% rpart.plot(roundint = FALSE)
```

```{r}
mush_rf_spec <- rand_forest(mtry= tune(), trees = tune(), min_n = tune()) %>% 
  set_engine("randomForest", importance = TRUE) %>% 
  set_mode("classification")

mush_rf_wf <- workflow() %>% 
  add_recipe(mush_recipe) %>% 
  add_model(mush_rf_spec)
```

```{r}
param_grid_rf <- grid_regular(mtry(range = c(1,19)),
                              trees(range = c(1,10)),
                              min_n(range = c(1,10)),
                              levels = 8)
param_grid_rf
```

```{r include= FALSE}
tune_res_rf <- tune_grid(mush_rf_wf, resamples = mush_folds, grid = param_grid_rf, metrics = metric_set(roc_auc))
```

```{r}
load(file = "tune_res_rf.rda")
autoplot(tune_res_rf)
```


```{r}
collect_metrics(tune_res_rf) %>% arrange(desc(mean))
best_parameter_rf <- select_best(tune_res_rf, metric = "roc_auc")
best_parameter_rf
```

```{r}
mush_rf_final <- finalize_workflow(mush_rf_wf, best_parameter_rf)
mush_rf_final_fit <- fit(mush_rf_final, data = mush_train)
```

```{r}
mush_rf_final_fit %>% extract_fit_engine() %>% vip()
```

```{r include= FALSE}
mush_boosted_spec <- boost_tree(trees = tune()) %>% 
  set_engine("xgboost") %>% 
  set_mode("classification")

mush_boosted_wf <- workflow() %>% 
  add_recipe(mush_recipe) %>% 
  add_model(mush_boosted_spec)

param_grid_boosted <- grid_regular(trees(range = c(10,2000)), levels = 10)
tune_res_boosted <- tune_grid(mush_boosted_wf, resamples = mush_folds, grid = param_grid_boosted, metrics = metric_set(roc_auc))
```

```{r}
autoplot(tune_res_boosted)
collect_metrics(tune_res_boosted) %>% arrange(desc(mean))
```

```{r}
best_parameter_boosted <- select_best(tune_res_boosted, metric = "roc_auc")
best_parameter_boosted
```

```{r}
tree_auc <- collect_metrics(tune_res_tree) %>% arrange(desc(mean))
forest_auc <- collect_metrics(tune_res_rf) %>% arrange(desc(mean))
boosted_auc <- collect_metrics(tune_res_boosted) %>% arrange(desc(mean))
roc_aucs <- c(tree_auc$mean[1], forest_auc$mean[1], boosted_auc$mean[1])
roc_aucs
```

```{r}
mush_final <- finalize_workflow(mush_boosted_wf, best_parameter_boosted)
mush_final_fit <- fit(mush_final, data = mush_train)
testing_roc_auc <- augment(mush_final_fit, new_data = mush_test) %>% 
  accuracy(truth = class, estimate = .pred_class)
testing_roc_auc
```

```{r}
final_model_conf <- augment(mush_final_fit, new_data = mush_test) %>% 
  conf_mat(truth = class, estimate = .pred_class) %>% 
  autoplot(type = "heatmap")
final_model_conf
```




